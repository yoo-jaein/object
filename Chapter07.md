# Chapter 07 객체 분해

## 추상화
불필요한 정보를 제거하고 문제 해결에 필요한 핵심만 남기는 것을 추상화라고 부른다. 추상화를 하게 되면 하나의 거대하고 복잡한 문제를 작은 문제로 나눌 수 있다. 나눠진 문제도 한 번에 해결하기 어렵다면 다시 더 작은 문제로 분해할 수 있다.  

## 추상화 메커니즘
### 1. 프로시저 추상화
프로시저 추상화(procedure abstraction)는 소프트웨어가 무엇을 해야 하는지를 추상화한다. 프로시저 추상화를 중심으로 시스템을 분해하면 기능 분해를 하는 것이다. 기능 분해는 알고리즘 분해라고도 한다. 

### 2. 데이터 추상화
데이터 추상화(data abstraction)는 소프트웨어가 무엇을 알아야 하는지를 추상화한다. 데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다. 하나는 데이터를 중심으로 타입을 추상화하는 것이고 다른 하나는 데이터를 중심으로 프로시저를 추상화하는 것이다. 전자를 추상 데이터 타입(Abstract Data Type)이라 하고 후자를 객체지향(Object-Oriented)라 한다. 

객체지향 프로그래밍은 데이터 추상화와 프로시저 추상화를 함께 포함한 '클래스'를 통해 시스템을 분해하는 것이다. 객체지향은 두 추상화 기법을 모두 사용하면서 전통적인 기능 분해 방법에 비해 효과적이다. 전통적인 기능 분해 방법이 어떻게 이루어지는지 살펴 보고 객체지향이 문제 해결에 효과적인 이유를 알아 보자.  

## 1. 프로시저 추상화
프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다. 전통적인 기능 분해 방식은 하향식 접근법(Top-Down Approach)을 따른다. 하향식 접근법은 시스템의 최상위 기능을 정의하고, 이 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다. 분해하는 작업은 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 반복한다.  

### 하향식 분해
#### 1단계
```text
직원의 급여를 계산한다.
```
급여 관리 시스템을 구현하기 위해 기능 분해 방법을 이용한다. 먼저 추상적인 최상위 문장을 기술하여 시작한다. 이 문장은 시스템을 시작하는 메인 프로시저로 구현될 것이다.

#### 2단계
```text
직원의 급여를 계산한다.
    사용자로부터 소득세율을 입력받는다.
    직원의 급여를 계산한다.
    양식에 맞게 결과를 출력한다.
```
최상위 문장은 위와 같이 세부적인 절차로 구체화되었다.

#### 3단계
```text
직원의 급여를 계산한다.
    사용자로부터 소득세율을 입력받는다.
        "세율을 입력하세요: "라는 문장을 화면에 출력한다.
        키보드를 통해 세율을 입력받는다.
    직원의 급여를 계산한다.
        전역 변수에 저장된 직원의 기본급 정보를 얻는다.
        급여를 계산한다.
    양식에 맞게 결과를 출력한다.
        "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
```
모든 문장이 좀 더 단순하고 구체적인 문장들의 조합으로 분해되었다. 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것이다. 

### 구현
구현 언어로 루비를 사용한다.

```ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def main(name)
    taxRate = getTaxRate()
    pay = calculatePayFor(name, taxRate)
    puts(describeResult(name, pay))
end

def getTaxRate()
    print("세율을 입력하세요: ")
    return gets().chomp().to_f()
end

def calculatePayFor(name, taxRate)
    index = $employees.index(name)
    basePay = $basePays[index]
    return basePay - (basePay * taxRate)
end

def describeResult(name, pay)
    return "이름: #{name}, 급여: #{pay}"
end
```

이름이 "직원C"인 직원의 급여를 계산하려면 다음과 같이 프로시저를 호출하면 된다.  

```ruby
main("직원C")
```

### 하향식 기능 분해의 문제점
1. 하나의 메인 함수(기능)이라는 비현실적인 생각
2. 기능 추가나 요구사항 변경으로 인해 메인 함수를 자주 수정해야 함
3. 비즈니스 로직과 사용자 인터페이스의 결합
4. 유연성과 재사용성 저하
5. 어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어렵기 때문에 파급효과를 예측하기 어려움

하향식 분해가 유용한 경우도 있다. 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 하향식 분해가 적합하다. 그러나 실제로 동작하는 커다란 소프트웨어를 설계하는 데는 적합하지 않다. 하나의 함수에 제어가 집중되어 코드의 재사용과 확장이 어렵고 데이터에 대한 영향도를 파악하기 어렵게 만든다.

## 2. 데이터 추상화
기존에 프로그램에서 사용하던 추상화 기법은 프로시저 추상화였다. 그러나 프로시저 추상화만으로는 프로그램을 자유롭게 확장하고 변경하는 데 한계가 있었다. 바바라 리스코프(Barbara Liskov)는 프로시저 추상화의 한계를 인지하고 이를 보완하기 위해 데이터 추상화의 개념을 제안했다.  

### 추상 데이터 타입
추상 데이터 타입은 시스템의 상태를 저장할 데이터를 표현한다. 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 로직은 추상 데이터 타입 외부에 존재한다. 급여 관리 시스템의 경우 main 함수의 로직들이 이 데이터를 사용하는 코드다. 추상 데이터 타입은 데이터에 대한 관점으로 설계를 하긴 하지만 여전히 데이터와 기능을 분리하는 '절차적인 설계'의 틀에 갇혀 있는 것이다.

### 추상 데이터 타입과 클래스
클래스는 추상 데이터 타입일까? 명확한 의미에서 두 타입은 동일하지 않다. 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다는 점이다. 상속과 다형성을 지원하는 ```객체 지향(Object-Oriented)``` 프로그래밍과 구분하기 위해 추상 데이터 타입 기반의 프로그래밍 패러다임을 ```객체기반(Object-Based)``` 프로그래밍이라고도 부른다.  

- 추상 데이터 타입은 (메서드)오퍼레이션을 기준으로 타입을 묶는다.
- 객체지향은 타입을 기준으로 오퍼레이션을 묶는다.

## 개방-폐쇄 원칙
클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 가장 간단한 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지를 살펴보는 것이다. 추상 데이터 타입으로 구현된 Employee 클래스에는 hourly 인스턴스 변수에 직원의 유형을 저장한다. 이처럼 인스턴스 변수의 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것이다. 객체지향에서는 [타입 변수를 이용한 조건문을 다형성으로 대체](https://github.com/yoo-jaein/refactoring/blob/main/Chapter%2012/memo.md#126-%ED%83%80%EC%9E%85-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%84%9C%EB%B8%8C%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0)한다.

객체지향은 새로운 직원 유형을 구현하는 클래스를 Employee 상속 계층에 추가하고 필요한 메서드를 오버라이딩하여 만든다. 시스템에 새로운 로직을 추가하기 위해 클라이언트 코드를 수정할 필요가 없다. 기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙(Open-Closed Principle, OCP)이라고 한다. 이것이 객체지향 설계가 전통적인 방식에 비해 변경하고 확장하기 쉬운 구조를 설계할 수 있는 이유다.

## 결론
1. 전통적인 기능 분해 방법인 하향식 접근법은 실제 소프트웨어 개발에 적합하지 않다.
2. 객체지향에서 중요한 것은 역할, 책임, 협력이다. 객체를 설계할때 협력이라는 문맥을 반드시 고려해야 한다.