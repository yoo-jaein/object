# Chapter 09 유연한 설계

## 개방-폐쇄 원칙
개방-폐쇄 원칙(Open-Closed Principle, OCP)이란 소프트웨어는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙이다.  

'확장에 대해 열려 있고 수정에 대해 닫혀 있다'는 말은 다시 말해 애플리케이션의 요구사항이 변경될 때 코드를 직접 수정하지 않고 기존의 협력 방식에 새로운 동작을 추가해야 한다는 것이다. [8장 마지막 예제](https://github.com/yoo-jaein/object/blob/main/Chapter08.md#%ED%99%95%EC%9E%A5-1-%ED%95%A0%EC%9D%B8-%ED%98%9C%ED%83%9D%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%98%81%ED%99%94)에서 알 수 있었던 것 처럼 새로운 조건이 생겼을 때 기존 코드를 수정하는 것은 예외 케이스를 추가하면서 버그 발생 확률을 높인다. 그렇기 때문에 기존 협력 방식을 수정하지 않고 설계를 확장시켜야 한다.

## 컴파일타임 의존성과 런타임 의존성
8장에서 컴파일타임 의존성과 런타임 의존성에 대해 알아봤다. 사실 개방-폐쇄 원칙은 두 의존성에 관한 이야기다. 개방-폐쇄 원칙을 따르는 코드는 컴파일타임 의존성을 (기존 코드를) 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다. 8장 마지막 예제에서 NoneDiscountPolicy, OverlappedDiscountPolicy를 추가하더라도 컴파일타임 의존성은 DiscountPolicy로 변하지 않는다. 변하는 것은 런타임 의존성이다.  

## 추상화
개방-폐쇄 원칙의 핵심은 **추상화에 의존하는 것**이다. 추상화를 하게 되면 협력하는 대상에게 불필요한 정보를 숨길 수 있다. 숨겨지지 않고 **남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물**이다. 이 부분은 변하지 않아야 한다.

## 생성과 사용을 분리
유연하고 재사용 가능한 설계를 원한다면 객체 생성 책임과 객체 사용 책임을 서로 다른 객체로 분리해야 한다.

### 팩토리
생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 팩토리(Factory)라고 부른다.  

### PURE FABRICATION
5장에서 [GRASP 패턴](https://github.com/yoo-jaein/object/blob/main/Chapter05.md#grasp-%ED%8C%A8%ED%84%B4)에 대해 살펴봤다. 기본적으로 객체 생성 책임은 도메인 모델 중 ```Information Expert```에게 할당한다. 그러나 팩토리의 경우 도메인 모델에 속하지 않는 '순수하게 기술적인 객체'이다. 이처럼 책임을 할당하기 위해 도메인과 무관하게 생성된 인공적인 객체를 ```Pure Fabrication```(순수한 가공물)이라고 부른다. 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 인공물들로 가득 차 있다.  

## 의존성 주입
외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 '의존성 주입'(Dependency Injection, DI)이라고 부른다. 이 기법을 의존성 주입이라고 부르는 이유는 외부에서 의존성 대상을 사용하는 객체 쪽으로 주입하기 때문이다. 

## 추상화와 의존성 역전
```java
public class Movie {
  private AmountDiscountPolicy discountPolicy;
}
```
이 설계가 변경에 취약한 이유는 Movie가 구체 클래스 AmountDiscountPolicy에 의존성을 가지기 때문이다. 다시 말해서 상위 수준 클래스인 Movie가 하위 수준 클래스 AmountDiscountPolicy에 의존하는 것이다. 이 설계를 개선하기 위해서는 추상화를 써야 한다. Movie와 AmountDiscountPolicy 모두가 추상화에 의존하도록 수정하면 하위 수준 클래스의 변경으로 인해 상위 수준 클래스가 영향을 받는 것을 방지할 수 있다. 추상 클래스 DiscountPolicy를 두고 AmountDiscountPolicy가 이를 의존하도록 만든다. Movie도 DiscountPolicy에 의존하도록 만든다. 이렇게 되면 상위 수준 클래스와 하위 수준 클래스가 모두 추상화에 의존하게 된다.  

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

이를 의존성 역전 원칙(Dependency Inversion Principle, DIP)이라고 부른다. '역전'이라는 단어가 사용된 이유는 잘 설계된 객체지향 프로그램의 의존성 구조가 전통적 절차적 방법에 의해 만들어진 의존성 구조에 대해 '역전'된 것이기 때문이다.

## 결론
1. 소프트웨어는 확장에 대해 열려 있고 수정에 대해 닫혀 있어야 한다.
2. 추상화에 의존하라.
