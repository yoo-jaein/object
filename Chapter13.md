# Chapter 13 서브클래싱과 서브타이핑

## 상속의 목적
1. 타입 계층 구현  
  타입 계층에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
2. 코드 재사용  
  간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다.

타입 사이의 관계를 고려하지 않고 단순히 코드 재사용만을 목적으로 상속을 사용해서는 안 된다.

## 슈퍼타입과 서브타입
### 내연과 외연의 관점
- ```슈퍼타입(supertype)``` : 집합이 다른 집합의 모든 멤버를 포함
- ```서브타입(subtype)``` : 집합에 포함되는 인스턴스들이 더 큰 집합에 포함

### 퍼블릭 인터페이스 관점
- ```슈퍼타입(supertype)``` : 서브타입이 정의한 **퍼블릭 인터페이스를 일반화**, 상대적으로 **범용적이고 넓은 의미**로 정의
- ```서브타입(subtype)``` : 슈퍼타입이 정의한 **퍼블릭 인터페이스를 특수화**, 상대적으로 **구체적이고 좁은 의미**로 정의

**서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.** -> 상속은 ```is-a 관계```에서만 사용되어야 한다.

## 행동의 호환
- 클라이언트의 관점에서 **자식 클래스와 부모 클래스의 행동이 호환될 경우에만** 타입 계층으로 묶어 **상속을 사용해야 한다.**  

## 인터페이스 분리 원칙
- Bird, FlyingBird, Penguin -> Flyer, Bird, Walker, Penguin

**Interface Segregation Principle, ISP**  

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙이다. 이 원칙을 적용하면 하나의 비대한 인터페이스 문제를 해결할 수 있다. 비대한 클래스의 인터페이스를 여러 개의 인터페이스로 분리하면서 클라이언트의 불필요한 의존성을 줄이고 독립성을 높일 수 있다.  

## 서브클래싱과 서브타이핑
- ```서브클래싱(subclassing)``` : ```구현 상속(implementation inheritance)```, ```클래스 상속(class inheritance)```  
  클래스의 **코드를 재사용할 목적**으로 상속을 사용하는 경우. 자식 클래스와 부모 클래스의 행동이 호환되지 않아 **자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.**  
- ```서브타이핑(subtyping)``` : ```인터페이스 상속(interface inheritance)```  
  **타입 계층을 구성**하기 위해 상속을 사용하는 경우. DiscountPolicy 상속 계층. **자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.**  

## 리스코프 치환 원칙
**Liskov Substitution Principle, LSP**  

서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다는 원칙이다. 행동 호환성을 설계 원칙으로 만든 것이다. Stack과 Vector는 리스코프 치환 원칙을 위반하는 전형적인 예다. 이것이 리스코프 치환 원칙을 위반하는 가장 큰 이유는 상속으로 인해 Stack에는 포함돼서는 안 되는 Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됐기 때문이다.
